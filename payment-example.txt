src/app/api/create-nowpayments-invoice/route.ts

import { NextResponse } from 'next/server';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid'; 
interface CreateInvoiceRequest {
  subscriptionPlanId: string;   price_amount: number;
  price_currency: string;
  order_description?: string; }

export async function POST(request: Request) {
  const apiKey = process.env.NOWPAYMENTS_API_KEY;
  console.log('[NOWPayments Invoice] API route hit.'); 
  if (!apiKey) {
    console.error('[NOWPayments Invoice] Error: NOWPayments API Key is not configured.');
    return NextResponse.json({ error: 'Payment gateway configuration error.' }, { status: 500 });
  }

  let body: CreateInvoiceRequest;
  try {
    body = await request.json();
    console.log('[NOWPayments Invoice] Received request body:', body);   } catch (parseError: any) {
    console.error('[NOWPayments Invoice] Error parsing request body:', parseError.message);
    return NextResponse.json({ error: 'Invalid request body.' }, { status: 400 });
  }

    if (!body.subscriptionPlanId || body.price_amount == null || !body.price_currency) {
     console.error('[NOWPayments Invoice] Validation Error: Missing required plan details.', {
         subscriptionPlanId: body.subscriptionPlanId,
         price_amount: body.price_amount,
         price_currency: body.price_currency
     });
    return NextResponse.json({ error: 'Missing required plan details (ID, amount, currency).' }, { status: 400 });
  }
  if (typeof body.price_amount !== 'number' || body.price_amount <= 0) {
      console.error('[NOWPayments Invoice] Validation Error: Invalid price amount.', { price_amount: body.price_amount });
      return NextResponse.json({ error: 'Invalid price amount.' }, { status: 400 });
  }

  const orderId = uuidv4(); 
    const payload = {
    price_amount: body.price_amount,
    price_currency: body.price_currency.toLowerCase(),     order_id: orderId,
    order_description: body.order_description || `IPTV Subscription Plan ID: ${body.subscriptionPlanId}`,     ipn_callback_url: `${process.env.NEXT_PUBLIC_BASE_URL || request.headers.get('origin')}/api/nowpayments-ipn`,
    success_url: `${process.env.NEXT_PUBLIC_BASE_URL || request.headers.get('origin')}/payment-successful?order_id=${orderId}`,     cancel_url: `${process.env.NEXT_PUBLIC_BASE_URL || request.headers.get('origin')}/payment-failed`,
    is_fee_paid_by_user: false, 
  };

  console.log('[NOWPayments Invoice] Attempting to create invoice with payload:', JSON.stringify(payload, null, 2)); // Log payload clearly

  try {
    const response = await axios.post(
      'https://api.nowpayments.io/v1/invoice',
      payload,
      {
        headers: {
          'x-api-key': apiKey,
          'Content-Type': 'application/json',
        },
        timeout: 10000,       }
    );

    console.log('[NOWPayments Invoice] API Response Status:', response.status);
    console.log('[NOWPayments Invoice] API Response Data:', response.data); // Log full response data

        if (response.data && response.data.invoice_url) {
      console.log(`[NOWPayments Invoice] Successfully created invoice ${response.data.id} for order ${orderId}. URL: ${response.data.invoice_url}`);
      return NextResponse.json({ invoice_url: response.data.invoice_url });
    } else {
      console.error('[NOWPayments Invoice] Error: Invoice URL not found in NOWPayments response.', response.data);
      throw new Error('Invoice URL not found in NOWPayments response.');
    }

  } catch (error: any) {
    console.error('[NOWPayments Invoice] Error calling NOWPayments API:', error.message);
    if (error.response) {
            console.error('[NOWPayments Invoice] API Error Status:', error.response.status);
      console.error('[NOWPayments Invoice] API Error Data:', error.response.data);
      return NextResponse.json({
          error: 'Failed to create payment invoice.',
          details: error.response.data?.message || 'NOWPayments API error',
          statusCode: error.response.data?.statusCode,
          errorCode: error.response.data?.code
        },
        { status: error.response.status || 500 }
      );
    } else if (error.request) {
                console.error('[NOWPayments Invoice] No response received from NOWPayments API:', error.request);
        return NextResponse.json({ error: 'Failed to create payment invoice.', details: 'No response from payment gateway.' }, { status: 504 });     } else {
                console.error('[NOWPayments Invoice] Error setting up request to NOWPayments:', error.message);
        return NextResponse.json({ error: 'Failed to create payment invoice.', details: 'Request setup error.' }, { status: 500 });
    }
  }
}

--------
src/app/api/nowpayments-ipn/route.ts


import { NextResponse } from 'next/server';
import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import { Resend } from 'resend';
import { getTranslations } from 'next-intl/server'; 
interface SavedPaymentDetails {
  email: string;
  mainLang: string;
  optLang1: string | null;
  optLang2: string | null;
  locale: string;   savedAt: string;
}

async function verifyNowPaymentsWebhook(request: Request, rawBody: string): Promise<boolean> {
  const signature = request.headers.get('x-nowpayments-sig');
  const ipnSecret = process.env.NOWPAYMENTS_IPN_SECRET; 
  if (!signature || !ipnSecret) {
    console.error('[IPN Verify] Failed: Missing signature or NOWPAYMENTS_IPN_SECRET.');
    return false;
  }

  try {
        let sortedBodyString: string;
    try {
        const bodyJson = JSON.parse(rawBody);
                const sortObject = (obj: any): any => {
            if (typeof obj !== 'object' || obj === null) return obj;
            if (Array.isArray(obj)) return obj.map(sortObject);
            const sortedKeys = Object.keys(obj).sort();
            const result: { [key: string]: any } = {};
            sortedKeys.forEach(key => { result[key] = sortObject(obj[key]); });
            return result;
        };
                sortedBodyString = JSON.stringify(sortObject(bodyJson));
    } catch (e) {
        console.error('[IPN Verify] Failed to parse/sort raw body for signature verification:', e);
        console.error('[IPN Verify] Raw body received:', rawBody);
        return false;     }

    const hmac = crypto.createHmac('sha512', ipnSecret);
    const calculatedSignature = hmac.update(sortedBodyString).digest('hex');

        const sigBuffer = Buffer.from(signature, 'utf8');
    const calculatedSigBuffer = Buffer.from(calculatedSignature, 'utf8');

    if (sigBuffer.length !== calculatedSigBuffer.length || !crypto.timingSafeEqual(sigBuffer, calculatedSigBuffer)) {
       console.error('[IPN Verify] Failed: Invalid signature.');
                            return false;
    }

    console.log('[IPN Verify] Signature verified successfully.');
    return true;
  } catch (error) {
    console.error('[IPN Verify] Error during signature verification:', error);
    return false;
  }
}

function generateCredentials(): { username: string; password: string } {
    const username = `user_${crypto.randomBytes(4).toString('hex')}`;
    const password = crypto.randomBytes(8).toString('hex');
    console.log('[IPN Creds] Generated:', { username });     return { username, password };
}

async function sendConfirmationEmail(
    customerEmail: string,
    credentials: { username: string; password: string },
    languagePrefs: { mainLang: string; optLang1: string | null; optLang2: string | null },
    paymentDetails: any,
    t: Function ): Promise<boolean> {
    console.log(`[IPN Email] Attempting to send email to: ${customerEmail} for order ${paymentDetails.order_id}`);
    const resendApiKey = process.env.RESEND_API_KEY;
    const senderAddress = process.env.EMAIL_SENDER_ADDRESS;

    if (!resendApiKey || !senderAddress) {
        console.error('[IPN Email] Resend API Key or Sender Address not configured in .env');
        return false;
    }

    const resend = new Resend(resendApiKey);

        const subject = t('confirmationEmail.subject', { orderId: paymentDetails.order_id || 'N/A' });
    const bodyText = `${t('confirmationEmail.greeting')}

${t('confirmationEmail.orderDetailsHeader')}
${t('confirmationEmail.orderIdLabel')} ${paymentDetails.order_id || 'N/A'}
${t('confirmationEmail.paymentIdLabel')} ${paymentDetails.payment_id || 'N/A'}
${t('confirmationEmail.amountPaidLabel')} ${paymentDetails.actually_paid || paymentDetails.pay_amount} ${paymentDetails.pay_currency?.toUpperCase()}

${t('confirmationEmail.credentialsHeader')}
${t('confirmationEmail.usernameLabel')} ${credentials.username}
${t('confirmationEmail.passwordLabel')} ${credentials.password}

${t('confirmationEmail.languagePrefsHeader')}
${t('confirmationEmail.mainLangLabel')} ${languagePrefs.mainLang}
${t('confirmationEmail.optLang1Label')} ${languagePrefs.optLang1 || t('confirmationEmail.none')}
${t('confirmationEmail.optLang2Label')} ${languagePrefs.optLang2 || t('confirmationEmail.none')}

${t('confirmationEmail.safetyNote')}

${t('confirmationEmail.closing')}
${t('confirmationEmail.teamName')}`;

    const bodyHtml = `<p>${t('confirmationEmail.greeting')}</p>
<p>
  ${t('confirmationEmail.orderDetailsHeader')}<br>
  ${t('confirmationEmail.orderIdLabel')} ${paymentDetails.order_id || 'N/A'}<br>
  ${t('confirmationEmail.paymentIdLabel')} ${paymentDetails.payment_id || 'N/A'}<br>
  ${t('confirmationEmail.amountPaidLabel')} ${paymentDetails.actually_paid || paymentDetails.pay_amount} ${paymentDetails.pay_currency?.toUpperCase()}
</p>
<p><strong>${t('confirmationEmail.credentialsHeader')}</strong><br>
  ${t('confirmationEmail.usernameLabel')} <code>${credentials.username}</code><br>
  ${t('confirmationEmail.passwordLabel')} <code>${credentials.password}</code>
</p>
<p><strong>${t('confirmationEmail.languagePrefsHeader')}</strong><br>
  ${t('confirmationEmail.mainLangLabel')} ${languagePrefs.mainLang}<br>
  ${t('confirmationEmail.optLang1Label')} ${languagePrefs.optLang1 || t('confirmationEmail.none')}<br>
  ${t('confirmationEmail.optLang2Label')} ${languagePrefs.optLang2 || t('confirmationEmail.none')}
</p>
<p>${t('confirmationEmail.safetyNote')}</p>
<p>${t('confirmationEmail.closing')}<br>${t('confirmationEmail.teamName')}</p>`;
    
    try {
        const { data, error } = await resend.emails.send({
            from: senderAddress,
            to: [customerEmail],
            subject: subject,
            text: bodyText,
            html: bodyHtml,
        });

        if (error) {
          console.error(`[IPN Email] Resend API Error for order ${paymentDetails.order_id}:`, error);
          return false;
        }

        console.log(`[IPN Email] Confirmation email sent successfully via Resend for order ${paymentDetails.order_id}. Email ID:`, data?.id);
        return true;
    } catch (error) {
        console.error(`[IPN Email] Exception sending confirmation email for order ${paymentDetails.order_id}:`, error);
        return false;
    }
}

const tempDir = path.join(os.tmpdir(), 'iptvdudes_order_details');

export async function POST(request: Request) {
  let rawBody = '';
  try {
    rawBody = await request.text();
    console.log('[IPN Handler] Received IPN request.');

        const isValid = await verifyNowPaymentsWebhook(request, rawBody);
    if (!isValid) {
      console.error('[IPN Handler] Invalid signature. Ignoring request.');
      return NextResponse.json({ message: 'Invalid signature.' }, { status: 200 });     }

        const data = JSON.parse(rawBody);
    const paymentId = data.payment_id;
    const orderId = data.order_id;
    const paymentStatus = data.payment_status;

    console.log(`[IPN Handler] Processing IPN for Payment ID: ${paymentId}, Order ID: ${orderId}, Status: ${paymentStatus}`);

        const successfulStatus = 'finished';

    if (paymentStatus === successfulStatus) {
      console.log(`[IPN Handler] Payment finished for Order ID: ${orderId}. Proceeding with fulfillment.`);

      if (!orderId) {
          console.error(`[IPN Handler] Order ID missing in 'finished' payload for Payment ID: ${paymentId}. Cannot fulfill.`);
          return NextResponse.json({ message: 'Webhook processed, but Order ID missing.' }, { status: 200 });
      }

            const safeOrderId = orderId.replace(/[^a-zA-Z0-9_-]/g, '');
      const filePath = path.join(tempDir, `order_${safeOrderId}.json`);
      let savedDetails: (SavedPaymentDetails & { locale: string }) | null = null; 
      try {
          const fileContent = await fs.readFile(filePath, 'utf-8');
          savedDetails = JSON.parse(fileContent);
          console.log(`[IPN Handler] Successfully read details for order ${safeOrderId} from ${filePath}`);
      } catch (fileError: any) {
          console.error(`[IPN Handler] Error reading details file ${filePath} for order ${safeOrderId}:`, fileError.message);
                    return NextResponse.json({ message: 'Webhook processed, but failed to retrieve customer details for fulfillment.' }, { status: 200 });
      }

            if (!savedDetails || !savedDetails.email || !savedDetails.locale) {
           console.error(`[IPN Handler] Email or Locale missing in retrieved details for order ${safeOrderId}. Cannot fulfill.`);
           return NextResponse.json({ message: 'Webhook processed, but customer email or locale missing in saved details.' }, { status: 200 });
      }

            let t: Function;
      try {
                    const validLocale = ['en', 'es', 'fr', 'de', 'pt', 'ar'].includes(savedDetails.locale) ? savedDetails.locale : 'en';
          t = await getTranslations({ locale: validLocale, namespace: 'common' });
          console.log(`[IPN Handler] Loaded translations for locale: ${validLocale}`);
      } catch (translationError) {
          console.error(`[IPN Handler] Failed to load translations for locale ${savedDetails.locale}:`, translationError);
                    return NextResponse.json({ message: 'Webhook processed, but failed to load translations.' }, { status: 200 });
      }

            const credentials = generateCredentials();

            const emailSent = await sendConfirmationEmail(
          savedDetails.email,
          credentials,
          { mainLang: savedDetails.mainLang, optLang1: savedDetails.optLang1, optLang2: savedDetails.optLang2 },
          data,           t       );

      if (emailSent) {
                    try {
              await fs.unlink(filePath);
              console.log(`[IPN Handler] Successfully deleted details file ${filePath}`);
          } catch (deleteError: any) {
              console.error(`[IPN Handler] Error deleting details file ${filePath} after successful processing:`, deleteError.message);
                        }
      } else {
          console.error(`[IPN Handler] Failed to send confirmation email for order ${safeOrderId}. Temporary file NOT deleted.`);
                }

    } else {
      console.log(`[IPN Handler] Received status '${paymentStatus}' for order ${orderId}. No fulfillment action taken.`);
    }

        console.log(`[IPN Handler] Acknowledging webhook for payment ${paymentId}.`);
    return NextResponse.json({ message: 'Webhook received successfully' });

  } catch (error: any) {
    console.error('[IPN Handler] Uncaught error processing webhook:', error.message);
    console.error('[IPN Handler] Raw body was:', rawBody);
        return NextResponse.json({ message: 'Internal server error processing webhook.' }, { status: 200 });
  }
}


------
src/app/api/save-payment-details/route.ts


import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';
import os from 'os'; 
interface SaveDetailsRequest {
  orderId: string;
  email: string;
  mainLang: string;
  optLang1: string | null;
  optLang2: string | null;
  locale: string; }

const tempDir = path.join(os.tmpdir(), 'iptvdudes_order_details'); 
async function ensureTempDir() {
  try {
    await fs.mkdir(tempDir, { recursive: true });
    console.log(`Temporary directory ensured: ${tempDir}`);
  } catch (error) {
    console.error(`Error creating temporary directory ${tempDir}:`, error);
      }
}

export async function POST(request: Request) {
  console.log('[Save Details] API route hit.');
  let details: SaveDetailsRequest;

  try {
    details = await request.json();
    console.log('[Save Details] Received details:', details);
  } catch (parseError: any) {
    console.error('[Save Details] Error parsing request body:', parseError.message);
    return NextResponse.json({ error: 'Invalid request body.' }, { status: 400 });
  }

    if (!details.orderId || !details.email || !details.mainLang || !details.locale) {     console.error('[Save Details] Validation Error: Missing required details (orderId, email, mainLang, locale).', details);
    return NextResponse.json({ error: 'Missing required details.' }, { status: 400 });
  }

    if (!/\S+@\S+\.\S+/.test(details.email)) {
     console.error('[Save Details] Validation Error: Invalid email format.', { email: details.email });
     return NextResponse.json({ error: 'Invalid email format.' }, { status: 400 });
  }

    await ensureTempDir();

        const safeOrderId = details.orderId.replace(/[^a-zA-Z0-9_-]/g, '');
  if (!safeOrderId) {
      console.error('[Save Details] Invalid Order ID after sanitization.');
      return NextResponse.json({ error: 'Invalid Order ID.' }, { status: 400 });
  }
  const filePath = path.join(tempDir, `order_${safeOrderId}.json`);

  try {
        const dataToSave = {
      email: details.email,
      mainLang: details.mainLang,
      optLang1: details.optLang1,
      optLang2: details.optLang2,
      locale: details.locale,       savedAt: new Date().toISOString(),
    };

        await fs.writeFile(filePath, JSON.stringify(dataToSave, null, 2));
    console.log(`[Save Details] Successfully saved details for order ${safeOrderId} to ${filePath}`);

    return NextResponse.json({ message: 'Preferences saved successfully.' });

  } catch (error: any) {
    console.error(`[Save Details] Error writing details file for order ${safeOrderId}:`, error.message);
    return NextResponse.json({ error: 'Failed to save preferences.', details: error.message }, { status: 500 });
  }
}



------
src/app/[locale]/payment-failed/page.tsx

'use client';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { useTranslations } from 'next-intl';
import { AlertTriangle } from 'lucide-react';

// Removed local PageProps interface

export default function PaymentFailedPage({ params }: { params: any }) { // Use 'any' as a workaround
  const { locale } = params;
  const t = useTranslations('common');

  return (
    <div className="container mx-auto px-4 py-12 min-h-screen flex flex-col items-center justify-center text-center">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        <AlertTriangle className="w-16 h-16 text-red-500 mx-auto mb-4" />
        <h1 className="text-4xl font-bold text-red-500 mb-4">
          {t('paymentFailed.title')}
        </h1>
        <p className="text-xl text-gray-700 dark:text-gray-300 mb-6">
          {t('paymentFailed.message')}
        </p>
        <p className="text-gray-600 dark:text-gray-400 mb-8">
          {t('paymentFailed.suggestion')}
        </p>
        <div className="flex flex-wrap gap-4 justify-center">
          <Link
            href={`/${locale}/#pricing`}
            className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-md transition-colors font-medium"
          >
            {t('paymentFailed.retryButton')}
          </Link>
          <Link
            href={`/${locale}/#contact`}
            className="bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-md transition-colors font-medium"
          >
            {t('paymentFailed.supportButton')}
          </Link>
        </div>
      </motion.div>
    </div>
  );
}



-----
src/app/[locale]/payment-successful/page.tsx


'use client';
import { useSearchParams } from 'next/navigation';
import { useTranslations } from 'next-intl';
import { Suspense, useState, FormEvent } from 'react'; import Link from 'next/link';
import { motion } from 'framer-motion';
import { CheckCircle, Loader2 } from 'lucide-react'; import axios from 'axios';
const languageOptions = [
  { value: 'en', label: 'English' },
  { value: 'es', label: 'Español' },
  { value: 'fr', label: 'Français' },
  { value: 'de', label: 'Deutsch' },
  { value: 'pt', label: 'Português' },
  { value: 'ar', label: 'العربية' },
];

function SuccessContent({ locale }: { locale: string }) {
  const searchParams = useSearchParams();
  const orderId = searchParams.get('order_id');
  const t = useTranslations('common');

  const [email, setEmail] = useState('');
  const [mainLang, setMainLang] = useState('');
  const [optLang1, setOptLang1] = useState('');
  const [optLang2, setOptLang2] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [formMessage, setFormMessage] = useState<{ type: 'success' | 'error'; text: string } | null>(null);
  const [formSubmitted, setFormSubmitted] = useState(false);
  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsLoading(true);
    setFormMessage(null);
    console.log('Submitting preferences:', { orderId, email, mainLang, optLang1, optLang2 });

    try {
      const response = await axios.post('/api/save-payment-details', {
        orderId: orderId || '', email,
        mainLang,
        optLang1: optLang1 || null, optLang2: optLang2 || null, locale: locale,
      });

      if (response.status === 200) {
        console.log('Preferences saved successfully');
        setFormMessage({ type: 'success', text: 'Preferences saved successfully! Your credentials will be emailed shortly.' });
        setFormSubmitted(true);
      } else {
        throw new Error(response.data?.error || 'Failed to save preferences');
      }
    } catch (error: any) {
      console.error('Error saving preferences:', error);
      const details = error.response?.data?.details || error.message || 'Unknown error';
      setFormMessage({ type: 'error', text: `Failed to save preferences: ${details}` });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      className="text-center w-full max-w-lg"     >
      <CheckCircle className="w-16 h-16 text-green-500 mx-auto mb-4" />
      <h1 className="text-4xl font-bold text-green-500 mb-4">
        {t('paymentSuccessful.title')}
      </h1>
      <p className="text-xl text-gray-700 dark:text-gray-300 mb-8">
        {t('paymentSuccessful.message', { orderId: orderId || 'N/A' })}
      </p>

      {/* Language Preference Form */}
      {!formSubmitted && (<form onSubmit={handleSubmit} className="mt-8 space-y-4 bg-gray-100 dark:bg-gray-800 p-6 rounded-lg shadow">
        <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-4">Confirm Details & Language Preferences</h2>

        {/* Email Input */}
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">
            Your Email Address (for credentials) <span className="text-red-500">*</span>
          </label>
          <input
            type="email"
            id="email"
            name="email"
            required
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            placeholder="you@example.com"
          />
        </div>

        {/* Main Language */}
        <div>
          <label htmlFor="mainLang" className="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">
            Main Language <span className="text-red-500">*</span>
          </label>
          <select
            id="mainLang"
            name="mainLang"
            required
            value={mainLang}
            onChange={(e) => setMainLang(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          >
            <option value="" disabled>Select main language...</option>
            {languageOptions.map(lang => (
              <option key={lang.value} value={lang.value}>{lang.label}</option>
            ))}
          </select>
        </div>

        {/* Optional Language 1 */}
        <div>
          <label htmlFor="optLang1" className="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">
            Optional Language 1
          </label>
          <select
            id="optLang1"
            name="optLang1"
            value={optLang1}
            onChange={(e) => setOptLang1(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          >
            <option value="">Select optional language...</option>
            {languageOptions.map(lang => (
              <option key={lang.value} value={lang.value}>{lang.label}</option>
            ))}
          </select>
        </div>

        {/* Optional Language 2 */}
        <div>
          <label htmlFor="optLang2" className="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">
            Optional Language 2
          </label>
          <select
            id="optLang2"
            name="optLang2"
            value={optLang2}
            onChange={(e) => setOptLang2(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          >
            <option value="">Select optional language...</option>
            {languageOptions.map(lang => (
              <option key={lang.value} value={lang.value}>{lang.label}</option>
            ))}
          </select>
        </div>

        {/* Hidden Order ID */}
        <input type="hidden" name="orderId" value={orderId || ''} />

        {/* Submit Button */}
        <button
          type="submit"
          disabled={isLoading || !email || !mainLang} className={`w-full flex justify-center items-center px-6 py-3 border border-transparent rounded-md shadow-sm text-base font-medium text-white ${(!email || !mainLang)
              ? 'bg-gray-400 cursor-not-allowed'
              : isLoading
                ? 'bg-blue-400 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500'
            }`}
        >
          {isLoading ? <Loader2 className="animate-spin h-5 w-5 mr-3" /> : null}
          Save Preferences & Get Credentials
        </button>

        {/* Form Messages */}
        {formMessage && (
          <p className={`mt-2 text-sm ${formMessage.type === 'error' ? 'text-red-600 dark:text-red-400' : 'text-green-600 dark:text-green-400'}`}>
            {formMessage.text}
          </p>
        )}
      </form>
      )}

      {/* Link to Homepage (shown after form submission or if form wasn't needed) */}
      {formSubmitted && (
        <Link
          href={`/${locale}/`}
          className="mt-8 inline-block bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-md transition-colors font-medium"
        >
          Go to Homepage
        </Link>
      )}
    </motion.div>
  );
}

export default function PaymentSuccessfulPage({ params }: { params: any }) { // Use 'any' as a workaround
  const { locale } = params;

  return (
    <div className="container mx-auto px-4 py-12 min-h-screen flex flex-col items-center justify-center">
      {/* Suspense is required when using useSearchParams in Pages */}
      <Suspense fallback={<div className="text-center"><Loader2 className="h-8 w-8 animate-spin mx-auto mb-4" />Loading confirmation...</div>}>
        <SuccessContent locale={locale} />
      </Suspense>
    </div>
  );
}



NOWPAYMENTS_API_KEY=KEYWSKW-1RSMS6N-PMPQCX6-RM91JWJ
NOWPAYMENTS_IPN_SECRET=ZwW8P2WqC9w/zF2L6JgXA0gBSbVD2sAX

# NOWPayments Subscription Plan IDs (Used in pricing component) I will need to use a once off id for this payment system in lore.meme
NEXT_PUBLIC_NOWPAYMENTS_PLAN_MONTHLY_ID=350602177


